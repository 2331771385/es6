<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        /*
            weakSet与set结构类似，都是存放的不重复的元素
            但是与set结构有两处不同的地方：
                1.weakSet中的成员都是对象
                2.weakSet中的对象成员都是弱引用，也就是说js的垃圾回收机制不会考虑weakSet对对象变量的引用。当其他地方对该对象的引用计数为0的时候，即使
                weakset还在使用该对象，垃圾回收机制也会对该对象进行回收。这样不会导致内存泄露。因此weakSet适合临时存放对象，以及存放跟对象绑定的信息
                只要这些对象再外部消失，那么在weakSet中的引用也会自动消失。
            由于weakSet中的成员都是弱引用，不知道变量在什么时候就消失了，因此该数据结构不能用于遍历，也就是不具备size属性，以及遍历器的方法
            wweakSet中有多少成员取决于垃圾回收有没有执行，可能某一个变量再垃圾回收之前存在，但在运行过程中，垃圾回收对该成员进行了回收，
            所以再运行后就不存在于该成员了。


            weakSet可以接受一个数组或类似数组的对象作为参数

        */
       let set=new WeakSet();
       //   若是向weakSet中添加[1,2,3,2]，此时回报错，因为数组中的成员不是对象，因此会报错
       //数组的成员只能是对象
    //    set.add(1);//使用add方法添加数值1，会报错
    //    set.add(Symbol('hh'));//使用Symbol结构的数据也会报错

    /*
        WeakSet {Symbol(Symbol.toStringTag): "WeakSet", constructor: ƒ, delete: ƒ, has: ƒ, add: ƒ}
            add: ƒ add()
            constructor: ƒ WeakSet()
            delete: ƒ delete()
            has: ƒ has()
            Symbol(Symbol.toStringTag): "WeakSet"
            __proto__: Object

        通过查看原型对象，可以看到这个数据结构中存在如下几个方法：
            1.add(),向结构中添加新成员
            2.delete(v);返回布尔值，表示删除是否成功
            3.has(v);返回布尔值，表示某一个成员是否再原结构中
    */
    console.log(WeakSet.prototype);
    </script>
</body>
</html>